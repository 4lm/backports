#!/usr/bin/env ruby
#
# dcp_inspect will inspect DCP media and directories.
# Copyright 2011 Wolfgang Woehl
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
AppName = File.basename( $0 )
AppVersion = 'v1.2012.01.08.backport'
#
# Usage:  dcp_inspect /path/to/dir
#         dcp_inspect --help
#
# Alpha stage so don't expect miracles. But it does bend over backwards to find 
# problems in packages.
#
# For convenience this backport carries almost all required infrastructure,
# including Julik's Timecode library (https://github.com/guerilla-di/timecode).
#
# 2 external requirements:
#   - asdcplib and its cli tools
#       http://www.cinecert.com/asdcplib/
#   - Nokogiri, a Ruby gem used for XML parsing and its dependencies
#       http://nokogiri.org/tutorials/installing_nokogiri.html
#
# Couple of todo's lurking:
#   - Consistency checks of package formats (Interop/SMPTE)
#   - Checks of listed and actual asset sizes
#   - Checks and verification of Signature/Certificates
#       For now dcp_inspect will just report Signer info
#   - Some Assetmap options (Offsets, volume indices) are not handled
#   - Marker lists in CPLs are not handled
#   - Its output is quite chatty and for now there is no way to tame that
#
# Tested on linux boxes. Let me know if dcp_inspect actually runs on Mac OS or Windows.
#
require 'nokogiri'
require 'optparse'
require 'ostruct'
require 'pathname'
require 'pp'
require 'shellwords'


# set up local XML Catalog and patch its xml:base
AppDir = File.dirname( Pathname.new( __FILE__ ).realpath )
XSDDir = File.join( AppDir, 'xsd' )
local_xml_catalog = File.join( XSDDir, 'catalog.xml' )
if File.exists?( XSDDir ) and File.ftype( XSDDir ) == 'directory'
  if File.exists? local_xml_catalog
    c = File.read local_xml_catalog
    m = c.match /xml:base="file:\/\/(.+)">/
    if m[ 1 ] != File.join( XSDDir, '' )
      File.open( local_xml_catalog, 'w' ) { |f| f.write c.gsub( m[ 1 ], File.join( XSDDir, '' ) ); f.close }
    end
  else
    puts "Local XML Catalog #{ local_xml_catalog } not found"
    exit
  end
else
  puts "Local XSD store #{ XSDDir } not found"
  exit
end
unless ENV[ 'XML_CATALOG_FILES' ]
  puts "Export env XML_CATALOG_FILES to point at #{ local_xml_catalog }"
  exit
end


# lib/options.rb
class Options
  def self.parse(args)
    # defaults
    options = OpenStruct.new
    options.check_hashes = FALSE
    options.validate = TRUE
    options.verbosity = 'debug'
    options.verbosity_choices = [ 'quiet', 'info', 'debug', 'trace_func' ]
    opts = OptionParser.new do |opts|
      opts.banner = <<BANNER
#{ AppName } #{ AppVersion }
 
BANNER
      opts.on( '-c', '--check-hashes', 'Compare listed and actual hash values of assets' ) do
        options.check_hashes = TRUE
      end
      opts.on( '--no-schema-checks', 'Skip schema checks' ) do
        options.validate = FALSE
      end
      opts.on( '-v', '--verbosity level', String, "Use 'quiet', 'info', 'debug' or 'trace_func' (Default: info)" ) do |p|
        if options.verbosity_choices.include?( p )
          options.verbosity = p
        else
          options.verbosity = "info"
        end
      end
      opts.on_tail( '-h', '--help', 'Display this screen' ) do
        puts opts
        exit
      end
    end
    begin
      opts.parse!( args )
    rescue Exception => e
      exit if e.class == SystemExit
      puts "Options error: #{ e.message }"
      exit
    end
    options
  end # parse
end # class

# * lib/logger.rb
class DLogger
  attr_accessor :prefix
  def initialize( prefix, verbosity )
    @verbosity = verbosity
    case @verbosity
    when "quiet"
      @info, @debug = [ FALSE, FALSE ]
    when "info"
      @info, @debug = [ TRUE, FALSE ]
    when "debug"
      @info, @debug = [ TRUE, TRUE ]
    when 'trace_func'
      @info, @debug = [ TRUE, TRUE ]
      set_trace_func proc { |event, file, line, id, binding, classname|
        printf "%8s %s:%-2d %10s %8s\n", event, file, line, id, classname
      }
    end
    @prefix = prefix
  end
  def info( text )
    to_console( text ) if @info == TRUE
  end
  def debug( text )
    to_console( text ) if @debug == TRUE
  end
  def cr( text )
    carriage_return( text ) unless @verbosity == "quiet"
  end
  def carriage_return( text )
    printf "#{ @prefix } #{ text }#{ ' ' * 64 }\r"; STDOUT.flush
  end
  def to_console( text )
    printf "#{ @prefix } #{ text }\n"
  end
end


# lib/mxf.rb
module MxfTools
  def mxf_inspect( filename )
    list = Shell.asdcp_mxf_info( filename )
    if list =~ /EditRate and SampleRate do not match \(24.000, 48.000\)/ and list =~ /File may contain JPEG Interop stereoscopic images/
      list = Shell.asdcp_mxf_interop_stereoscopic_info( filename )
    end
    if list.empty? or list =~ /Program stopped on error/
      return nil
    end
    list = list.split( /\n\s*/ ).collect { |line| line.split( ': ' ) }
    et = [ 'EssenceType', 
           case list.first.to_s
           when /#{ MStr::Stereoscopic_pictures }/
             MStr::Stereoscopic_pictures
           when /#{ MStr::Pictures }/
             MStr::Pictures
           when /#{ MStr::Mpeg2 }/
             MStr::Mpeg2
           when /#{ MStr::Audio }/
             MStr::Audio
           when /#{ MStr::Timed_text }/i
             MStr::Timed_text 
           else
             nil
           end 
    ]
    return Hash[ list << et ]
  end
end
include MxfTools


# lib/magic_strings.rb
module MStr
  Smpte_am    = 'http://www.smpte-ra.org/schemas/429-9/2007/AM'
  Smpte_pkl   = 'http://www.smpte-ra.org/schemas/429-8/2007/PKL'
  Smpte_cpl   = 'http://www.smpte-ra.org/schemas/429-7/2006/CPL'
  Interop_am  = 'http://www.digicine.com/PROTO-ASDCP-AM-20040311#'
  Interop_pkl = 'http://www.digicine.com/PROTO-ASDCP-PKL-20040311#'
  Interop_cpl = 'http://www.digicine.com/PROTO-ASDCP-CPL-20040511#'

  Schemas = {
    Smpte_am    => 'SMPTE-429-9-2007-AM.xsd',
    Smpte_pkl   => 'SMPTE-429-8-2006-PKL.xsd',
    Smpte_cpl   => 'SMPTE-429-7-2006-CPL.xsd',
    Interop_am  => 'PROTO-ASDCP-AM-20040311.xsd',
    Interop_pkl => 'PROTO-ASDCP-PKL-20040311.xsd',
    Interop_cpl => 'PROTO-ASDCP-CPL-20040511.xsd'
  }

  # title_kind_aspect_langaudio-langsubs only
  Naming_re = /([-A-Z0-9]+)_(FTR|FTR-1|FTR-2|TST|TLR|TLR-1|TLR1-2D|TLR1-3D|RTG-F|RTG-T1|TSR|TSR-1|POL|PSA|ADV|SHR|XSN|)_(F|S|C)_([A-Z]{2}-[A-Z]{2})/
  Stereoscopic_pictures = 'stereoscopic pictures'
  Pictures = 'pictures'
  Mpeg2 = 'MPEG2 video'
  Audio = 'audio'
  Timed_text = 'timed text'
end # module MStr
include MStr


# lib/shell_tools.rb
module Shell
  class << self
    def uuid_new
      `kmuuidgen -n`
    end
    def asdcp_mxf_info( filename )
      `asdcp-test -v -i #{ filename } 2>&1`.chomp
    end
    def asdcp_mxf_interop_stereoscopic_info( filename )
      `asdcp-test -3 -v -i #{ filename } 2>&1`.chomp
    end
    def asdcp_digest( filename )
      `asdcp-test -t #{ filename }`.chomp.split( ' ' ).first
    end
  end
end


# lib/tools.rb
# date helpers
require 'date'
def time_to_datetime( time ) # OpenSSL's ruby bindings return Time objects for certificate validity info
  DateTime.parse( time.to_s )
end
def datetime_friendly( dt ) # return something in the form of "Tuesday Nov 30 2010 (18:56)"
  "#{ DateTime::DAYNAMES[ dt.wday ] } #{ DateTime::ABBR_MONTHNAMES[ dt.month ] } #{ dt.day.to_s } #{ dt.year.to_s } #{ '%02d' % dt.hour.to_s }:#{ '%02d' % dt.min.to_s }"
end
def yyyymmdd( datetime ) # used in KDM filenames. See http://www.kdmnamingconvention.com/
  datetime.to_s.split( 'T' ).first.gsub( /-/,'' )
end
def hours_minutes_seconds_verbose( seconds )
  t = seconds
  hrs = ( ( t / 3600 ) ).to_i
  min = ( ( t / 60 ) % 60 ).to_i
  sec = t % 60
  return [
    hrs > 0 ? hrs.to_s + " hour#{ 's' * ( hrs > 1 ? 1 : 0 ) }" : nil ,
    min > 0 ? min.to_s + " minute#{ 's' * ( min > 1 ? 1 : 0 ) }" : nil ,
    sec == 1 ? sec.to_i.to_s + ' second' : sec != 0 ? sec.to_s + ' seconds' : nil ,
    t > 60 ? "(#{ t } seconds)" : nil
  ].compact.join( ' ' )
end
def hms_from_seconds( seconds )
  hours = ( seconds / 3600.0 ).to_i
  minutes = ( ( seconds / 60.0 ) % 60 ).to_i
  secs = seconds % 60
  return [ hours, minutes, secs ].join( ':' )
end
def seconds_from_hms( timestring ) # hh:mm:ss.fraction
  a = timestring.split( ':' )
  hours = a[ 0 ].to_i
  minutes = a[ 1 ].to_i
  secs = a[ 2 ].to_f
  return ( hours * 3600 + minutes * 60 + secs )
end


# misc helpers
#
# plural helper english
def pl( list )
  list.size != 1 ? 's' : ''
end
# package path helper
def package( relative_path )
  File.join( @package_dir, relative_path )
end


# lib/timecode-ticks_tc.rb (Julik's timecode -- https://github.com/guerilla-di/timecode + parse_with_ticks)
# Timecode is a convenience object for calculating SMPTE timecode natively. 
# The promise is that you only have to store two values to know the timecode - the amount
# of frames and the framerate. An additional perk might be to save the dropframeness,
# but we avoid that at this point.
#
# You can calculate in timecode objects as well as with conventional integers and floats.
# Timecode is immutable and can be used as a value object. Timecode objects are sortable.
#
# Here's how to use it with ActiveRecord (your column names will be source_tc_frames_total and tape_fps)
#
#   composed_of :source_tc, :class_name => 'Timecode',
#     :mapping => [%w(source_tc_frames total), %w(tape_fps fps)]

class Timecode
  VERSION = '1.0.0'

  include Comparable
  
  DEFAULT_FPS = 25.0
  
  #:stopdoc:
  NTSC_FPS = (30.0 * 1000 / 1001).freeze
  FILMSYNC_FPS = (24.0 * 1000 / 1001).freeze
  ALLOWED_FPS_DELTA = (0.001).freeze
  
  COMPLETE_TC_RE = /^(\d{2}):(\d{2}):(\d{2}):(\d{2})$/
  COMPLETE_TC_RE_24 = /^(\d{2}):(\d{2}):(\d{2})\+(\d{2})$/
  DF_TC_RE = /^(\d{1,2}):(\d{1,2}):(\d{1,2});(\d{2})$/
  FRACTIONAL_TC_RE = /^(\d{2}):(\d{2}):(\d{2})\.(\d{1,8})$/
  TICKS_TC_RE = /^(\d{2}):(\d{2}):(\d{2}):(\d{3})$/
  
  WITH_FRACTIONS_OF_SECOND = "%02d:%02d:%02d.%02d"
  WITH_FRAMES = "%02d:%02d:%02d:%02d"
  WITH_FRAMES_24 = "%02d:%02d:%02d+%02d"
  
  #:startdoc:
  
  # All Timecode lib errors inherit from this
  class Error < RuntimeError; end
  
  # Gets raised if timecode is out of range (like 100 hours long)
  class RangeError < Error; end

  # Gets raised when a timecode cannot be parsed
  class CannotParse < Error; end

  # Gets raised when you try to compute two timecodes with different framerates together
  class WrongFramerate < ArgumentError; end
  
  # Initialize a new Timecode object with a certain amount of frames and a framerate
  # will be interpreted as the total number of frames
  def initialize(total = 0, fps = DEFAULT_FPS)
    raise WrongFramerate, "FPS cannot be zero" if fps.zero?
    
    # If total is a string, use parse
    raise RangeError, "Timecode cannot be negative" if total.to_i < 0
    # Always cast framerate to float, and num of rames to integer
    @total, @fps = total.to_i, fps.to_f
    @value = validate!
    freeze
  end
  
  def inspect # :nodoc:
    "#<Timecode:%s (%dF@%.2f)>" % [to_s, total, fps]
  end
  
  class << self
    
    # Use initialize for integers and parsing for strings
    def new(from, fps = DEFAULT_FPS)
      from.is_a?(String) ? parse(from, fps) : super(from, fps)
    end
    
    # Parse timecode and return zero if none matched
    def soft_parse(input, with_fps = DEFAULT_FPS)
      parse(input) rescue new(0, with_fps)
    end
      
    # Parse timecode entered by the user. Will raise if the string cannot be parsed.
    # The following formats are supported:
    # * 10h 20m 10s 1f (or any combination thereof) - will be disassembled to hours, frames, seconds and so on automatically
    # * 123 - will be parsed as 00:00:01:23
    # * 00:00:00:00 - will be parsed as zero TC
    def parse(input, with_fps = DEFAULT_FPS)
      # Drop frame goodbye
      if (input =~ DF_TC_RE)
        raise Error, "We do not support drop-frame TC"
      # 00:00:00:00
      elsif (input =~ COMPLETE_TC_RE)
        atoms_and_fps = input.scan(COMPLETE_TC_RE).to_a.flatten.map{|e| e.to_i} + [with_fps]
        return at(*atoms_and_fps)
      # 00:00:00+00
      elsif (input =~ COMPLETE_TC_RE_24)
        atoms_and_fps = input.scan(COMPLETE_TC_RE_24).to_a.flatten.map{|e| e.to_i} + [24]
        return at(*atoms_and_fps)
      # 00:00:00.0
      elsif input =~ FRACTIONAL_TC_RE
        parse_with_fractional_seconds(input, with_fps)
      # 00:00:00:000
      elsif input =~ TICKS_TC_RE
        parse_with_ticks(input, with_fps)
      # 10h 20m 10s 1f 00:00:00:01 - space separated is a sum of parts
      elsif input =~ /\s/
        parts = input.gsub(/\s/, ' ').split.reject{|e| e.strip.empty? }
        raise CannotParse, "No atoms" if parts.empty?
        parts.map{|part|  parse(part, with_fps) }.inject{|sum, p| sum + p.total }
      # 10s
      elsif input =~ /^(\d+)s$/
        return new(input.to_i * with_fps, with_fps)
      # 10h
      elsif input =~ /^(\d+)h$/i
        return new(input.to_i * 60 * 60 * with_fps, with_fps)
      # 20m
      elsif input =~ /^(\d+)m$/i
        return new(input.to_i * 60 * with_fps, with_fps)
      # 60f - 60 frames, or 2 seconds and 10 frames
      elsif input =~ /^(\d+)f$/i
        return new(input.to_i, with_fps)
      # Only a bunch of digits, treat 12345 as 00:01:23:45
      elsif (input =~ /^(\d+)$/)
        atoms_len = 2 * 4
        # left-pad input AND truncate if needed
        padded = input[0..atoms_len].rjust(8, "0")
        atoms = padded.scan(/(\d{2})/).flatten.map{|e| e.to_i } + [with_fps]
        return at(*atoms)
      else
        raise CannotParse, "Cannot parse #{input} into timecode, unknown format"
      end
    end
    
    # Initialize a Timecode object at this specfic timecode
    def at(hrs, mins, secs, frames, with_fps = DEFAULT_FPS)
      validate_atoms!(hrs, mins, secs, frames, with_fps)
      total = (hrs*(60*60*with_fps) +  mins*(60*with_fps) + secs*with_fps + frames).round
      new(total, with_fps)
    end
    
    # Validate the passed atoms for the concrete framerate
    def validate_atoms!(hrs, mins, secs, frames, with_fps)
      case true
        when hrs > 99
          raise RangeError, "There can be no more than 99 hours, got #{hrs}"
        when mins > 59
          raise RangeError, "There can be no more than 59 minutes, got #{mins}"
        when secs > 59
          raise RangeError, "There can be no more than 59 seconds, got #{secs}"
        when frames > (with_fps -1)
          raise RangeError, "There can be no more than #{with_fps -1} frames @#{with_fps}, got #{frames}"
      end
    end
    
    # Parse a timecode with fractional seconds instead of frames. This is how ffmpeg reports
    # a timecode
    def parse_with_fractional_seconds(tc_with_fractions_of_second, fps = DEFAULT_FPS)
      fraction_expr = /\.(\d+)$/
      fraction_part = ('.' + tc_with_fractions_of_second.scan(fraction_expr)[0][0]).to_f

      seconds_per_frame = 1.0 / fps.to_f
      frame_idx = (fraction_part / seconds_per_frame).floor

      tc_with_frameno = tc_with_fractions_of_second.gsub(fraction_expr, ":%02d" % frame_idx)

      parse(tc_with_frameno, fps)
    end

    # Parse a timecode with ticks of a second instead of frames. A 'tick' is defined as 
    # 4 msec and has a range of 0 to 249. This format can show up in subtitle files for digital cinema
    def parse_with_ticks(tc_with_ticks, fps = DEFAULT_FPS)
      ticks_expr = /(\d{3})$/ 
      ticks_part = (tc_with_ticks.scan(ticks_expr)[0][0]).to_i

      seconds_per_frame = 1.0 / fps
      frame_idx = ((ticks_part * 0.004) / seconds_per_frame ).floor

      tc_with_frameno = tc_with_ticks.gsub(ticks_expr, "%02d" % frame_idx)

      parse(tc_with_frameno, fps)
    end
  
    # create a timecode from the number of seconds. This is how current time is supplied by
    # QuickTime and other systems which have non-frame-based timescales
    def from_seconds(seconds_float, the_fps = DEFAULT_FPS)
      total_frames = (seconds_float.to_f * the_fps.to_f).to_i
      new(total_frames, the_fps)
    end
  
    # Some systems (like SGIs) and DPX format store timecode as unsigned integer, bit-packed. This method
    # unpacks such an integer into a timecode.
    def from_uint(uint, fps = DEFAULT_FPS)
      tc_elements = (0..7).to_a.reverse.map do | multiplier | 
        ((uint >> (multiplier * 4)) & 0x0F)
      end.join.scan(/(\d{2})/).flatten.map{|e| e.to_i}

      tc_elements << fps
      at(*tc_elements)
    end
  end
  
  def coerce(to)
    me = case to
      when String
        to_s
      when Integer
        to_i
      when Float
        to_f
      else
        self
    end
    [me, to]
  end
  
  # is the timecode at 00:00:00:00
  def zero?
    @total.zero?
  end
  
  # get total frame count
  def total
    to_f
  end
  
  # get FPS
  def fps
    @fps
  end
    
  # get the number of frames
  def frames
    value_parts[3]
  end
  
  # get the number of seconds
  def seconds
    value_parts[2]
  end
  
  # get the number of minutes
  def minutes
    value_parts[1]
  end
  
  # get the number of hours
  def hours
    value_parts[0]
  end
  
  # get frame interval in fractions of a second
  def frame_interval
    1.0/@fps
  end
  
  # get the timecode as bit-packed unsigned 32 bit int (suitable for DPX and SGI)
  def to_uint
    elements = (("%02d" * 4) % [hours,minutes,seconds,frames]).split(//).map{|e| e.to_i }
    uint = 0
    elements.reverse.each_with_index do | p, i |
      uint |= p << 4 * i 
    end
    uint
  end
  
  # get the timecode as a floating-point number of seconds (used in Quicktime)
  def to_seconds
    (@total / @fps)
  end
  
  # Convert to different framerate based on the total frames. Therefore,
  # 1 second of PAL video will convert to 25 frames of NTSC (this 
  # is suitable for PAL to film TC conversions and back).
  def convert(new_fps)
    self.class.new(@total, new_fps)
  end
  
  # get formatted SMPTE timecode
  def to_s
    if (framerate_in_delta(fps, 24))
      WITH_FRAMES_24 % value_parts
    else
      WITH_FRAMES % value_parts
    end
  end
  
  # get total frames as float
  def to_f
    @total
  end

  # get total frames as integer
  def to_i
    @total
  end
  
  # add number of frames (or another timecode) to this one
  def +(arg)
    if (arg.is_a?(Timecode) && framerate_in_delta(arg.fps, @fps))
      self.class.new(@total+arg.total, @fps)
    elsif (arg.is_a?(Timecode))
      raise WrongFramerate, "You are calculating timecodes with different framerates"
    else
      self.class.new(@total + arg, @fps)
    end
  end
  
  # Tells whether the passes timecode is immediately to the left or to the right of that one
  # with a 1 frame difference
  def adjacent_to?(another)
    (self.succ == another) || (another.succ == self)
  end
  
  # Subtract a number of frames
  def -(arg)
    if (arg.is_a?(Timecode) &&  framerate_in_delta(arg.fps, @fps))
      self.class.new(@total-arg.total, @fps)
    elsif (arg.is_a?(Timecode))
      raise WrongFramerate, "You are calculating timecodes with different framerates"
    else
      self.class.new(@total-arg, @fps)
    end
  end
  
  # Multiply the timecode by a number
  def *(arg)
    raise RangeError, "Timecode multiplier cannot be negative" if (arg < 0)
    self.class.new(@total*arg.to_i, @fps)
  end
  
  # Get the next frame
  def succ
    self.class.new(@total + 1, @fps)
  end
  
  # Get the number of times a passed timecode fits into this time span (if performed with Timecode) or 
  # a Timecode that multiplied by arg will give this one
  def /(arg)
    arg.is_a?(Timecode) ?  (@total / arg.total) : self.class.new(@total / arg, @fps)
  end
  
  # Timecodes can be compared to each other
  def <=>(other_tc)
    if framerate_in_delta(fps, other_tc.fps)
      self.total <=> other_tc.total
    else 
      raise WrongFramerate, "Cannot compare timecodes with different framerates"
    end
  end
  
  # FFmpeg expects a fraction of a second as the last element instead of number of frames. Use this
  # method to get the timecode that adheres to that expectation. The return of this method can be fed
  # to ffmpeg directly.
  #  Timecode.parse("00:00:10:24", 25).with_frames_as_fraction #=> "00:00:10.96"
  def with_frames_as_fraction
    vp = value_parts.dup
    vp[-1] = (100.0 / @fps) * vp[-1]
    WITH_FRACTIONS_OF_SECOND % vp
  end
  alias_method :with_fractional_seconds, :with_frames_as_fraction
  
  # Validate that framerates are within a small delta deviation considerable for floats
  def framerate_in_delta(one, two)
    (one.to_f - two.to_f).abs <= ALLOWED_FPS_DELTA
  end
  
  private
  
  # Prepare and format the values for TC output
  def validate!
    frames = @total
    secs = (@total.to_f/@fps).floor
    frames-=(secs*@fps)
    mins = (secs/60).floor
    secs -= (mins*60)
    hrs = (mins/60).floor
    mins-= (hrs*60)

    self.class.validate_atoms!(hrs, mins, secs, frames, @fps)

    [hrs, mins, secs, frames]
  end
  
  def value_parts
    @value ||= validate!
  end
  
end


# lib/xml.rb
# Out in the field there will be Signer elements
#   - with Issuer name and Subject name (SMPTE)
#   - with Issuer name only
def xml_get_signer( xml )
  # FIXME
  xml = xml.dup
  xml.remove_namespaces!
  signers = xml.xpath( '//CompositionPlaylist/Signer' )
  if signers.size == 1
    issuer = xml.xpath( '//CompositionPlaylist/Signer/X509Data/X509IssuerSerial/X509IssuerName' ).text
    subject = xml.xpath( '//CompositionPlaylist/Signer/X509Data/X509SubjectName' ).text
    return {
      'Issuer' => ( issuer == '' ? 'Element not present' : issuer ),
      'Subject' => ( subject == '' ? 'Element not present' : subject )
    }
  elsif signers.size > 1
    @logger.info "Found #{ signers.size } Signer nodes (1 allowed)"
    # FIXME elaborate
    return NIL
  else
    return NIL
  end
end

# returns validated xml or false.
# in addition to xml all kinds of stuff will be examined here
# hence the hoopla to skip expected errors from non-xml.
# still: what an appaling method
def get_xml_of_type( asdcp_type, file, validate = TRUE )
  begin
    xml = Nokogiri::XML( open file )
  rescue Exception => e
    @logger.info "#{ file }: #{ e.message }"
    return FALSE
  end
  unless xml.errors.empty?
    xml.errors.each do |e|
      # expected errors from non-xml
      next if e.message =~ /Start tag expected/ or e.message =~ /Document is empty/
      @logger.info "Syntax error: #{ file }: #{ e }"
    end
    return FALSE
  end

  case xml.root.node_name
  when asdcp_type

    # skip validation
    return xml unless validate

    # find schema match
    case asdcp_type
    # special handling as DCSubtitle files are not namespaced
    when 'DCSubtitle'
      # alpha stage
      xsd_file = 'DCSubtitle.v1.mattsson.xsd'
    else
      case asdcp_type
      when 'AssetMap'
        # fhg output will be prefixed
        xsd_file = ( Schemas[ xml.namespaces[ 'xmlns' ] ] or Schemas[ xml.namespaces[ 'xmlns:am' ] ] )
      else
        xsd_file = ( Schemas[ xml.namespaces[ 'xmlns' ] ] )
      end
    end
    xsd = Nokogiri::XML::Schema( open File.join( XSDDir, xsd_file ) )
    validation_errors = xsd.validate( xml )
    if validation_errors.empty?
      @logger.debug( "Schema check: #{ File.basename xsd_file }: #{ file }: No errors" )
      return xml
    else
      validation_errors.each do |e|
        @logger.info "Schema check: #{ File.basename xsd_file }: Error: #{ file }: #{ e.inspect }"
        return FALSE
      end
    end
  else # not the type we're looking for
    return FALSE
  end # case xml.root.node_name
end

def xml?( file )
  begin
    xml = Nokogiri::XML( open file )
  rescue Exception => e
    return FALSE
  end
  if xml.root.nil?
    return FALSE
  else
    xml
  end
end

# FIXME Rather brittle mechanism here. I'd like to have infrastructure types show up (CompositionPlaylist, PackingList, DCSubtitle, DCMetadata)
def get_asset_uuid( file )
  id = nil
  if File.exists?( file )
    xml = xml?( file )
    if xml
      xml.remove_namespaces!

      # FIXME how to find the first child level Id only?
      ids = xml.xpath( '//Id' )
      if ids.size > 0
        id = ids.first.text.split( ':' ).last
      else
        id = xml.xpath( '//SubtitleID' ).text # DCSubtitle
        if id.empty?
          id = xml.xpath( '//MetadataID' ).text # PCF, DCMetadata
        end
      end

    else # not xml
      meta = MxfTools.mxf_inspect( file )
      if meta
        id = meta[ 'AssetUUID' ]
      end
    end

  end
  return id
end


# lib/cpl.rb
def cpl_inspect_xml( xml, dict, package_dir, errors, hints, info, options )
  ns = xml.namespaces
  cpl_id = xml.xpath( '//xmlns:CompositionPlaylist/xmlns:Id' ).text.split( ':' ).last
  case ns[ 'xmlns' ]
  when MStr::Smpte_cpl
    cpl_type = 'SMPTE'
  when MStr::Interop_cpl
    cpl_type = 'Interop'
  else
    cpl_type = 'Unknown'
    errors << "CPL main namespace unknown: #{ package dict[ cpl_id ] }: #{ cpl_id }: #{ ns[ 'xmlns' ] }"
  end
  report = Array.new
  report << "CPL Id:           #{ cpl_id }"
  report << "CPL file:         #{ dict[ cpl_id ] }"
  report << "CPL type:         #{ cpl_type } (#{ ns[ 'xmlns' ].inspect })"
  content_title_text = xml.xpath( '//xmlns:CompositionPlaylist/xmlns:ContentTitleText' ).text
  report << "ContentTitleText: #{ content_title_text }"
  if content_title_text =~ MStr::Naming_re
    matchdata = content_title_text.match( MStr::Naming_re )
    if matchdata
      if matchdata[ 4 ] # langaudio-langsubs
        report << "\tLanguage audio and subtitles: #{ matchdata[ 4 ] }"
      end
    end
  end
  report << "AnnotationText:   #{ xml.xpath( '//xmlns:CompositionPlaylist/xmlns:AnnotationText' ).text }"
  report << "ContentKind:      #{ xml.xpath( '//xmlns:CompositionPlaylist/xmlns:ContentKind' ).text }"
  dt = xml.xpath( '//xmlns:CompositionPlaylist/xmlns:IssueDate' ).text
  dt_friendly = datetime_friendly( DateTime.parse dt )
  report << "IssueDate:        #{ dt } (#{ dt_friendly })"
  report << "Issuer:           #{ xml.xpath( '//xmlns:CompositionPlaylist/xmlns:Issuer' ).text }"
  report << "Creator:          #{ xml.xpath( '//xmlns:CompositionPlaylist/xmlns:Creator' ).text }"

  # Metadata
  if xml.collect_namespaces.keys.include?( 'xmlns:meta' )
    cma = xml.xpath( '//meta:CompositionMetadataAsset/meta:*', 'meta' => xml.collect_namespaces[ 'xmlns:meta' ] )
    if cma
      report << "CompositionMetadataAsset:"
      cma.each do |e|
        report << "\t#{ e.node_name }: #{ e.text }"
      end
    end
  end

  signer = xml_get_signer( xml )
  if signer
    report << "Signer:           #{ signer.inspect }"
    info << "Signer: CPL #{ cpl_id }: #{ signer.inspect }"
  else
    report << "Not signed"
  end

  reels = xml.xpath( '//xmlns:CompositionPlaylist/xmlns:ReelList/xmlns:Reel' )
  report << "Number of Reels:  #{ reels.size }"
  total_duration = 0
  composition_edit_rate = 0
  reels.each_with_index do |reel, index|
    report << "Reel #{ index + 1 }:"
    durations = Array.new
    edit_rates = Array.new
    assets_labels = Array.new
    assets = reel.xpath( 'xmlns:AssetList/*' )

    assets.each do |asset|
      duration = asset.xpath( 'xmlns:Duration' ).text.to_i
      durations << duration
      asset_id = asset.xpath( 'xmlns:Id' ).text.split( ':' ).last
      edit_rate = asset.xpath( 'xmlns:EditRate' ).text.split( ' ' ).first.to_i # FIXME ugh
      edit_rates << edit_rate

      # A CPL might reference assets which are not in Assetmap's dictionary
      # (the asset might already be ingested or could be ingested later)
      #
      # A CPL might list metadata (current draft puts this into reel 1) with its
      # own asset id which will, again, not be part of Assetmap's dictionary.
      # Breaks reel durations (as of v1.2012.01.08.backport) for now. Not in
      # the wild yet.
      if dict
        if dict[ asset_id ]
          asset_file = package dict[ asset_id ]

          if File.exists?( asset_file )
            # Could be interop subtitle file
            xml = get_xml_of_type( 'DCSubtitle', asset_file, options.validate )
            if xml
              xml.remove_namespaces!
              if ( subtitles = xml.xpath( '//Subtitle' ) and subtitles.size > 0 )
                # scan all subtitles to find actual first_time_in and last_time_out
                # last subtitle is not necessarily the last displayed
                # not entirely sure that this might apply to first TimeIn as well
                first_time_in = '00:00:00:000'
                last_time_out = '00:00:00:000'
                subtitles.each do |sub|
                  time_in = sub.attributes[ 'TimeIn' ].value
                  time_out = sub.attributes[ 'TimeOut' ].value
                  first_time_in = time_in if first_time_in > time_in
                  last_time_out = time_out if last_time_out < time_out
                end
                first_time_in = Timecode.parse_with_ticks( first_time_in, edit_rate )
                last_time_out = Timecode.parse_with_ticks( last_time_out, edit_rate )
                meta_report = "DCSubtitle, #{ first_time_in } - #{ last_time_out }"
              else
                meta_report = "DCSubtitle, no Subtitle found"
              end
            else # not xml
              meta = MxfTools.mxf_inspect( asset_file )
              if meta
                meta_report = [
                  meta[ 'Label Set Type' ],
                  Timecode.new( meta[ 'ContainerDuration' ].to_i, edit_rate ).to_s,
                  meta[ 'EncryptedEssence' ] == 'Yes' ? 'encrypted' : 'unencrypted',
                  asset.node_name =~ /Picture/ ? meta[ 'StoredWidth' ] + 'x' + meta[ 'StoredHeight' ]  : '',
                  meta[ 'EssenceType' ]
                ].reject { |e| e.nil? or e.empty? }.join( ', ' )
              else
                meta_report = "Asset file found but not AS-DCP MXF"
              end
            end
          else
            meta_report = "Asset file missing: #{ dict[ asset_id ] }"
          end # File.exists?

        else
          meta_report = "Referenced asset file not listed in Assetmap dictionary"
          hint_info = [
            'CPL ' + cpl_id,
            asset_id,
            'Reel ' + ( index + 1 ).to_s,
            asset.node_name
          ].join( ': ' )
          hints << "Referenced asset file not listed in Assetmap dictionary: #{ hint_info }"
        end # if dict[ asset_id ]
      end # if dict

      report << "#{ "%6s" % duration }  #{ edit_rate == 0 ? 'NS Scope problem' : Timecode.new( duration, edit_rate ) } @ #{ edit_rate }  #{ asset_id }  #{ asset.node_name }\t(#{ meta_report })"

    end # assets.each
    if durations.uniq.size != 1
      report << "\tDuration mismatch"
      errors << "CPL (#{ content_title_text }): Reel #{ index + 1 }: Duration mismatch"
    end
    report << "\tEditRate mismatch" if edit_rates.uniq.size != 1
    total_duration += durations.min # FIXME ugh
    composition_edit_rate = edit_rates.min
  end # reels.each_with_index

  report << "Total duration:"
  report << "#{ "%6s" % total_duration }  #{ composition_edit_rate == 0 ? 'NS Scope problem' : Timecode.new( total_duration, composition_edit_rate ) } @ #{ composition_edit_rate }" # FIXME edit_rate

  return report, errors, hints, info
end


def dcp_inspect( options, args )
  errors = Array.new
  hints = Array.new
  hints << 'Schema checks were skipped' unless options.validate
  info = Array.new
  uuid_re = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/
  uuid_rfc4122_re = /^[0-9a-f]{8}-[0-9a-f]{4}-([1-5])[0-9a-f]{3}-[8-9a-b][0-9a-f]{3}-[0-9a-f]{12}$/

  # FIXME handle 1 arg and dir only for now
  if args.size == 1 and File.exists?( args.first ) and File.ftype( Pathname( args.first ).realpath ) == 'directory'
  
    # collect all files
    # see http://stackoverflow.com/a/2370805 for a portable and generic way to get at a tree's contents
    @package_dir = args.first
    package_dir_tree = Array.new
    Dir.chdir( @package_dir ) { |d| package_dir_tree = Dir[ "**/*" ] }
    
    # Find files called what Assetmap(s) would be called.
    # Don't assume they're actually Assetmaps before checking.
    am_candidates = package_dir_tree.select { |e| e =~ /ASSETMAP|ASSETMAP.xml/ }
    if am_candidates.empty?
      errors << 'No Assetmap candidates found' 
    else
      @logger.debug( "Found #{ am_candidates.size } Assetmap candidate#{ pl am_candidates }: #{ am_candidates.inspect }" )
    end

    # Check XML for Assetmap content
    unless am_candidates.empty?
      am_candidates.each do |am_candidate|
        xml = get_xml_of_type( 'AssetMap', package( am_candidate ), options.validate )
        if ! xml
          @logger.debug( errors.last )
          am_candidates.delete( am_candidate )
        end
      end
    end
    ams = am_candidates
    @logger.debug( "Found #{ ams.size }#{ options.validate ? ' valid' : '' } Assetmap#{ pl ams }" )
    # hint at multiple Assetmaps found
    hints << "Found #{ ams.size }#{ options.validate ? ' valid' : '' } Assetmaps" unless ams.size == 1

    # Process all Assetmaps
    dict = Array.new # list of dictionaries/hashes
    pkls = Array.new
    am_ids = Array.new
    ams.each_with_index do |am_file, index|
      dict << Hash.new
      pkls << Array.new
      am_base = File.dirname am_file
      xml = xml?( package am_file )
      # FIXME else all nodes searched need ns attached which would be, of course, the proper way to do it :)
      xml.remove_namespaces!
      am_id = get_asset_uuid( package am_file )
      if am_id
        am_ids << am_id
      else
        am_ids << NIL
        errors << "Assetmap '#{ am_file }' has no Id"
      end
      # collect all asset nodes
      assets = xml.xpath( '//Asset' )

      @logger.debug nil
      @logger.debug( "Assetmap #{ am_id }: #{ am_file }"  )

      # Store asset info in a dictionary (uuid => path, relative to package root)
      # look for PackingList(s)
      assets.each do |asset|

        listed_id = asset.xpath( 'Id' ).text.split( ':' ).last
        # FIXME ChunkList.size == 1 is an assumption and wrong at that. Could be > 1
        path = asset.xpath( 'ChunkList/Chunk/Path' ).text.split( /file:\/+/ ).last
        # using AM listed path for listing message, not package path, because this is what we're looking at right now:
        errors << "Listed in Assetmap: Not an RFC-4122 UUID: #{ listed_id }: #{ path }" unless listed_id =~ uuid_rfc4122_re
        if path.nil? # example: mc t28 ASSETMAP.xml
          errors << "#{ am_file } (#{ am_id }): No path for #{ listed_id }"
        else

          # Assetmap dictionary
          dict[ index ][ listed_id ] = Pathname( File.join( am_base, path ) ).cleanpath.to_s

          # Check listed_id vs actual asset_id
          if File.exists?( package dict[ index ][ listed_id ] )
            asset_id = get_asset_uuid( package dict[ index ][ listed_id ] )
            if asset_id
              unless asset_id =~ uuid_rfc4122_re
                errors << "Asset UUID: Not an RFC-4122 UUID: #{ asset_id }: #{ dict[ index ][ listed_id ] }"
              end
              if listed_id != asset_id
                errors << "#{ am_file } #{ am_id }: UUID mismatch: Listed: #{ listed_id } Asset: #{ asset_id }: #{ package dict[ index ][ listed_id ] }" 
              end
            end
          else
            errors << "Listed asset file missing: #{ am_file } #{ am_id }: #{ path }: #{ package dict[ index ][ listed_id ] }"
          end
        end

        # PackingList?
        unless asset.xpath( 'PackingList' ).empty?
          pkls[ index ] << listed_id 
        end

        # Check if possible uuid component in the asset filename matches the actual asset uuid
        if dict[ index ][ listed_id ]
          file_basename = File.basename( dict[ index ][ listed_id ] )
          if file_basename =~ uuid_re
            unless file_basename.match( uuid_re )[ 0 ] == listed_id
              hints << "Asset UUID and filename UUID component mismatch: #{ listed_id } -> #{ file_basename }"
            end
          end
        end
        
      end # assets.each

      # List asset dictionary
      @logger.debug( "Assetmap #{ am_id } lists #{ assets.size } asset#{ pl assets }:" )
      dict[ index ].map { |k, v| @logger.debug( "#{ [ k, v ].join( ': ' ) }#{ File.exists?( package v ) ? '' : ' (missing)' }" ) }

    end # ams.each

    # List all found PKLs if any
    @logger.debug nil unless ams.empty?
    am_ids.each_with_index do |am_id, index|
      @logger.debug( "Assetmap #{ am_id } lists #{ pkls[ index ].size } PKL#{ pl pkls[ index ] }:" )
      # FIXME purely informative here
      pkls[ index ].map { |pkl_id| @logger.debug( "PKL file#{ File.exists?( package dict[ index ][ pkl_id ] ) ? '' : ' not' } present: #{ [ pkl_id, dict[ index ][ pkl_id ] ].join( ': ' ) }" ) }
    end

    # All found PKLs: look for CPLs
    cpls = Array.new
    pkls.each_with_index do |am_pkls, index|
      am_pkls.each do |pkl_id|
        pkl_file = package dict[ index ][ pkl_id ]
        if File.exists?( pkl_file )
          xml = get_xml_of_type( 'PackingList', pkl_file, options.validate )
          if xml
            xml.remove_namespaces!
            pkl_assets = xml.xpath( '//Asset' )
            pkl_cpls = Array.new
            pkl_assets.each do |asset|
              id = asset.xpath( 'Id' ).text.split( ':' ).last
              type = asset.xpath( 'Type' ).text
              

              if dict[ index ].keys.include?( id )
                asset_file = package dict[ index ][ id ]

                if File.exists?( asset_file )
                  # Plug in checks here. we might be skipping validation hence the tag test
                  #
                  # Check listed and actual asset size
                  if ( size_listed = asset.xpath( 'Size' ).text.to_i )
                    size_asset = File.size( asset_file )
                    errors << "Size mismatch: #{ id }: #{ asset_file }: PKL: #{ size_listed } Asset: #{ size_asset }" unless size_listed == size_asset
                  else
                    errors << "PKL: Size tag missing or bad content: #{ id }: #{ asset_file }: #{ type }"
                  end

                  # Check listed and actual digests
                  if ( hash_listed = asset.xpath( 'Hash' ).text )
                    if options.check_hashes
                      @logger.debug "Checking hash value: #{ id }: #{ asset_file }"
                      hash_check = Shell::asdcp_digest( Shellwords.shellescape asset_file )
                      if hash_listed != hash_check
                        errors << "Hash mismatch: #{ id }: #{ asset_file }: PKL: #{ hash_listed } Asset: #{ hash_check }"
                      else
                        info << "Hash value checked OK: #{ id } #{ asset_file }: #{ hash_check }"
                      end
                    end
                  else
                    errors << "PKL: Hash tag missing or bad content: #{ asset_file }: #{ type }: #{ id }"
                  end

                  # Pick CPLs
                  if type =~ /text\/xml/
                    xml = get_xml_of_type( 'CompositionPlaylist', asset_file, options.validate )
                    if xml
                      pkl_cpls << id
                    else
                      # we might hit subtitle files here
                    end
                  end
                  #
                  #
                else
                  # asset_file does not exist
                end

              else
                # For some reason the listed id in PackingList is not in assetmap dictionary
                # Possibly been tampered with
                errors << "PKL (#{ pkl_id }): Asset UUID not in assetmap dictionary: #{ id } (#{ type })"
              end

            end
            # Add this PKLs CPLs to total CPLs
            cpls += pkl_cpls
            # List this PKLs CPLs
            @logger.debug nil
            @logger.debug( "PKL #{ pkl_id } lists #{ pkl_cpls.size }#{ options.validate ? ' valid' : '' } composition#{ pl pkl_cpls }" )
            # FIXME purely informative here, we don't remember referenced files which are missing
            pkl_cpls.map { |cpl_id| @logger.debug( "CPL file#{ File.exists?( package dict[ index ][ cpl_id ] ) ? '' : ' not' } present: #{ [ cpl_id, dict[ index ][ cpl_id ] ].join( ': ' ) }" ) }
          else
            errors << "Not a PackingList: #{ pkl_file }"
          end
        else
          errors << "AM referenced PKL file not found: #{ pkl_file }"
        end
      end
    end

    # List all found CPLs
    @logger.debug nil
    if cpls.size > 0
      @logger.debug( "Found #{ cpls.size }#{ options.validate ? ' valid' : '' } composition#{ pl cpls }:" )
      dict.each do |dictionary|
        cpls.each do |cpl_id|
          if dictionary.include?( cpl_id )
            @logger.debug( "CPL file#{ File.exists?( package dictionary[ cpl_id ] ) ? '' : ' not' } present: #{ [ cpl_id, dictionary[ cpl_id ] ].join( ': ' ) }" )
          end
        end
      end
    else
      @logger.info( "Found no#{ options.validate ? ' valid' : '' } compositions" )
    end

    # Inspect CPLs
    # FIXME and all over again ...
    dict.each do |dictionary|
      cpls.each do |cpl_id|
        if dictionary.include?( cpl_id )
          cpl_file = package dictionary[ cpl_id ]
          if File.exists?( cpl_file )
            xml = xml?( cpl_file )
            if xml
              report, errors, hints, info = cpl_inspect_xml( xml, dictionary, @package_dir, errors, hints, info, options )
            else
              errors << "PKL listed CPL is not XML: #{ cpl_file }: #{ cpl_id }"
            end
          else
            report << "CPL file missing: #{ cpl_file }"
          end
          report.map { |line| @logger.info line }
          @logger.info ''
        end
      end
    end

  elsif args.size == 0
    @logger.info( "No volume or directory given. See #{ AppName } --help" )
  elsif args.size > 1
    @logger.info( "Too many arguments. See #{ AppName } --help" )
  else
    @logger.info( "Not a volume or directory. See #{ AppName } --help" )
  end

  # info << 'todo: Package format: Interop/SMPTE'
  # info << 'todo: Assetmap: Offsets, Lengths, VolumeIndex'
  # info << 'todo: Signature/Certificates: Check and verify (See PLATES for some invalid ones)'
  info << "#{ options.validate ? 'Validated' : 'Not validated' }: #{ ams.size } Assetmap#{ pl ams }, #{ pkls.size } PKL#{ pl pkls }, #{ cpls.size } CPL#{ pl cpls }"

  errors.map { |e| @logger.info [ 'Error', e ].join( ': ' ) } unless errors.empty?
  hints.map { |e| @logger.info [ 'Hint', e ].join( ': ' ) } unless hints.empty?
  info.map { |e| @logger.info [ 'Info', e ].join( ': ' ) } unless info.empty?
end


#
options = Options.parse( ARGV )
args = ARGV
@logger = DLogger.new( prefix = '', options.verbosity )
@logger.debug( "#{ AppName }: #{ args } #{ options.validate ? '' : ': Schema checks will be skipped' }" )
dcp_inspect( options, args )

